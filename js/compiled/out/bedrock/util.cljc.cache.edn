{:rename-macros {}, :renames {}, :externs {Date {prototype {getTime {}}}, goog {string {StringBuffer {prototype {append {}}}}}}, :use-macros {}, :excludes #{}, :name bedrock.util, :imports nil, :requires {clojure.string clojure.string, walk clojure.walk, clojure.walk clojure.walk, cljs.pprint cljs.pprint, string clojure.string}, :cljs.spec/speced-vars [], :uses nil, :defs {partial-2 {:protocol-inline nil, :meta {:file "/Users/jonasgreen/workspace/stateless/src/bedrock/util.cljc", :line 27, :column 7, :end-line 27, :end-column 16, :arglists (quote ([f & args])), :doc "As partial, but slices the bound args in after the second unbound one", :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(f args)], :arglists ([f & args]), :arglists-meta (nil)}}, :name bedrock.util/partial-2, :variadic true, :file "src/bedrock/util.cljc", :end-column 16, :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(f args)], :arglists ([f & args]), :arglists-meta (nil)}, :method-params [(f args)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 27, :end-line 27, :max-fixed-arity 1, :fn-var true, :arglists ([f & args]), :doc "As partial, but slices the bound args in after the second unbound one"}, walk-seq {:protocol-inline nil, :meta {:file "/Users/jonasgreen/workspace/stateless/src/bedrock/util.cljc", :line 429, :column 7, :end-line 429, :end-column 15, :arglists (quote ([k transform xs])), :doc "Walks a sequence of maps, updates children under key k.\n\n  Example:\n\n  (walk-seq\n       :sub\n       (fn [this parent] (assoc this :par (:id parent)))\n       [{:id 12\n         :sub [{:id 5 :sub [{:id 67} {:id 99}]}\n        {:id 50}]}])\n  ==> ({:id 12, :sub ({:id 5\n                       :sub ({:id 67, :par 5}\n                             {:id 99, :par 5})\n                       :par 12}\n      {:id 50, :par 12})\n      :par nil})"}, :name bedrock.util/walk-seq, :variadic false, :file "src/bedrock/util.cljc", :end-column 15, :method-params ([k transform xs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 429, :end-line 429, :max-fixed-arity 3, :fn-var true, :arglists (quote ([k transform xs])), :doc "Walks a sequence of maps, updates children under key k.\n\n  Example:\n\n  (walk-seq\n       :sub\n       (fn [this parent] (assoc this :par (:id parent)))\n       [{:id 12\n         :sub [{:id 5 :sub [{:id 67} {:id 99}]}\n        {:id 50}]}])\n  ==> ({:id 12, :sub ({:id 5\n                       :sub ({:id 67, :par 5}\n                             {:id 99, :par 5})\n                       :par 12}\n      {:id 50, :par 12})\n      :par nil})"}, get-time {:protocol-inline nil, :meta {:file "/Users/jonasgreen/workspace/stateless/src/bedrock/util.cljc", :line 59, :column 7, :end-line 59, :end-column 15, :arglists (quote ([])), :doc "Get current time in milliseconds"}, :name bedrock.util/get-time, :variadic false, :file "src/bedrock/util.cljc", :end-column 15, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 59, :end-line 59, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Get current time in milliseconds"}, side-effect {:protocol-inline nil, :meta {:file "/Users/jonasgreen/workspace/stateless/src/bedrock/util.cljc", :line 337, :column 7, :end-line 337, :end-column 18, :arglists (quote ([f a & rest])), :doc "Performs side-effect f on argument-list, then returns first arg", :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(f a rest)], :arglists ([f a & rest]), :arglists-meta (nil)}}, :name bedrock.util/side-effect, :variadic true, :file "src/bedrock/util.cljc", :end-column 18, :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(f a rest)], :arglists ([f a & rest]), :arglists-meta (nil)}, :method-params [(f a rest)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 337, :end-line 337, :max-fixed-arity 2, :fn-var true, :arglists ([f a & rest]), :doc "Performs side-effect f on argument-list, then returns first arg"}, pp-str' {:protocol-inline nil, :meta {:file "/Users/jonasgreen/workspace/stateless/src/bedrock/util.cljc", :line 75, :column 7, :end-line 75, :end-column 14, :arglists (quote ([x & [ns]])), :doc "pprint to a string, shortening functions. nb! for human consumption only.\n   The optional ns-or-kw argument determines a namespace that is printed as ::.\n   If ns is a string, it's treated as a namespace-name, if it's a keyword, the\n   namespace of the keyword is understood. If it's :short namespaces are shortened", :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(x [ns])], :arglists ([x & [ns]]), :arglists-meta (nil)}}, :name bedrock.util/pp-str', :variadic true, :file "src/bedrock/util.cljc", :end-column 14, :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(x [ns])], :arglists ([x & [ns]]), :arglists-meta (nil)}, :method-params [(x [ns])], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 75, :end-line 75, :max-fixed-arity 1, :fn-var true, :arglists ([x & [ns]]), :doc "pprint to a string, shortening functions. nb! for human consumption only.\n   The optional ns-or-kw argument determines a namespace that is printed as ::.\n   If ns is a string, it's treated as a namespace-name, if it's a keyword, the\n   namespace of the keyword is understood. If it's :short namespaces are shortened"}, outer-join-with {:protocol-inline nil, :meta {:file "/Users/jonasgreen/workspace/stateless/src/bedrock/util.cljc", :line 162, :column 7, :end-line 162, :end-column 22, :arglists (quote ([merge-fn key-fn & colls])), :doc "As outer join, but takes a merging function that is applied to combine\n   all 'rows' that result in the same key-value, (from left to right).\n\n   Example:\n\n  (outer-join-with vector\n                   (comp even? :a)\n                   [{:a 1 :b 10 :c 100}{:a 2 :b 20 :c 200}{:a 2 :b 5 :c 500}]\n                   [{:a 2 :b 20 :d 200}{:a 2 :b 25 :d 200}{:a 3 :b 30 :d 300}])\n  ==> ([{:a 1, :b 10, :c 100} {:a 3, :b 30, :d 300}]\n       [{:a 2, :b 20, :c 200} {:a 2, :b 5, :c 500}\n        {:a 2, :b 20, :d 200} {:a 2, :b 25, :d 200}])\n\n  (outer-join-with (comp count list)\n                   :a\n                   [{:a 1 :b 10 :c 100}{:a 2 :b 20 :c 200}]\n                   [{:a 2 :b 20 :d 200}{:a 3 :b 30 :d 300}])\n  ==> (1 2 1)\n\n  (outer-join-with (comp + :c)\n                   :a\n                   [{:a 1 :b 10 :c 100}{:a 2 :b 20 :c 200}]\n                   [{:a 2 :b 20 :d 200}{:a 3 :b 30 :d 300}])\n   ==> (100 200 nil)", :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(merge-fn key-fn colls)], :arglists ([merge-fn key-fn & colls]), :arglists-meta (nil)}}, :name bedrock.util/outer-join-with, :variadic true, :file "src/bedrock/util.cljc", :end-column 22, :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(merge-fn key-fn colls)], :arglists ([merge-fn key-fn & colls]), :arglists-meta (nil)}, :method-params [(merge-fn key-fn colls)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 162, :end-line 162, :max-fixed-arity 2, :fn-var true, :arglists ([merge-fn key-fn & colls]), :doc "As outer join, but takes a merging function that is applied to combine\n   all 'rows' that result in the same key-value, (from left to right).\n\n   Example:\n\n  (outer-join-with vector\n                   (comp even? :a)\n                   [{:a 1 :b 10 :c 100}{:a 2 :b 20 :c 200}{:a 2 :b 5 :c 500}]\n                   [{:a 2 :b 20 :d 200}{:a 2 :b 25 :d 200}{:a 3 :b 30 :d 300}])\n  ==> ([{:a 1, :b 10, :c 100} {:a 3, :b 30, :d 300}]\n       [{:a 2, :b 20, :c 200} {:a 2, :b 5, :c 500}\n        {:a 2, :b 20, :d 200} {:a 2, :b 25, :d 200}])\n\n  (outer-join-with (comp count list)\n                   :a\n                   [{:a 1 :b 10 :c 100}{:a 2 :b 20 :c 200}]\n                   [{:a 2 :b 20 :d 200}{:a 3 :b 30 :d 300}])\n  ==> (1 2 1)\n\n  (outer-join-with (comp + :c)\n                   :a\n                   [{:a 1 :b 10 :c 100}{:a 2 :b 20 :c 200}]\n                   [{:a 2 :b 20 :d 200}{:a 3 :b 30 :d 300}])\n   ==> (100 200 nil)"}, comp> {:protocol-inline nil, :meta {:file "/Users/jonasgreen/workspace/stateless/src/bedrock/util.cljc", :line 102, :column 7, :end-line 102, :end-column 12, :arglists (quote ([& fns])), :doc "Composes a list functions for application from left to right, treating nil as identity", :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(fns)], :arglists ([& fns]), :arglists-meta (nil)}}, :name bedrock.util/comp>, :variadic true, :file "src/bedrock/util.cljc", :end-column 12, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(fns)], :arglists ([& fns]), :arglists-meta (nil)}, :method-params [(fns)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 102, :end-line 102, :max-fixed-arity 0, :fn-var true, :arglists ([& fns]), :doc "Composes a list functions for application from left to right, treating nil as identity"}, wrapper {:protocol-inline nil, :meta {:file "/Users/jonasgreen/workspace/stateless/src/bedrock/util.cljc", :line 369, :column 7, :end-line 369, :end-column 14, :arglists (quote ([& [f-pre f-post]])), :doc "Makes a function wrapper with optional pre and post processing", :top-fn {:variadic true, :max-fixed-arity 0, :method-params [([f-pre f-post])], :arglists ([& [f-pre f-post]]), :arglists-meta (nil)}}, :name bedrock.util/wrapper, :variadic true, :file "src/bedrock/util.cljc", :end-column 14, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [([f-pre f-post])], :arglists ([& [f-pre f-post]]), :arglists-meta (nil)}, :method-params [([f-pre f-post])], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 369, :end-line 369, :max-fixed-arity 0, :fn-var true, :arglists ([& [f-pre f-post]]), :doc "Makes a function wrapper with optional pre and post processing"}, guard {:protocol-inline nil, :meta {:file "/Users/jonasgreen/workspace/stateless/src/bedrock/util.cljc", :line 12, :column 7, :end-line 12, :end-column 12, :arglists (quote ([pred x])), :doc "Guards a value by predicate on said value"}, :name bedrock.util/guard, :variadic false, :file "src/bedrock/util.cljc", :end-column 12, :method-params ([pred x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 12, :end-line 12, :max-fixed-arity 2, :fn-var true, :arglists (quote ([pred x])), :doc "Guards a value by predicate on said value"}, flatten-1-clean {:protocol-inline nil, :meta {:file "/Users/jonasgreen/workspace/stateless/src/bedrock/util.cljc", :line 32, :column 7, :end-line 32, :end-column 22, :arglists (quote ([xs])), :doc "Flattens a seq by 1 level and removes nils"}, :name bedrock.util/flatten-1-clean, :variadic false, :file "src/bedrock/util.cljc", :end-column 22, :method-params ([xs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 32, :end-line 32, :max-fixed-arity 1, :fn-var true, :arglists (quote ([xs])), :doc "Flattens a seq by 1 level and removes nils"}, prn-str' {:protocol-inline nil, :meta {:file "/Users/jonasgreen/workspace/stateless/src/bedrock/util.cljc", :line 92, :column 7, :end-line 92, :end-column 15, :arglists (quote ([x & [opt]])), :doc "identity with (println pp-str' % %2) as side effect", :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(x [opt])], :arglists ([x & [opt]]), :arglists-meta (nil)}}, :name bedrock.util/prn-str', :variadic true, :file "src/bedrock/util.cljc", :end-column 15, :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(x [opt])], :arglists ([x & [opt]]), :arglists-meta (nil)}, :method-params [(x [opt])], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 92, :end-line 92, :max-fixed-arity 1, :fn-var true, :arglists ([x & [opt]]), :doc "identity with (println pp-str' % %2) as side effect"}, listify {:protocol-inline nil, :meta {:file "/Users/jonasgreen/workspace/stateless/src/bedrock/util.cljc", :line 305, :column 7, :end-line 305, :end-column 14, :arglists (quote ([x])), :doc "Promotes a proper non-sequential to a list of one element, and turns non-list sequentials into seq's"}, :name bedrock.util/listify, :variadic false, :file "src/bedrock/util.cljc", :end-column 14, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 305, :end-line 305, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Promotes a proper non-sequential to a list of one element, and turns non-list sequentials into seq's"}, outer-join {:protocol-inline nil, :meta {:file "/Users/jonasgreen/workspace/stateless/src/bedrock/util.cljc", :line 195, :column 7, :end-line 195, :end-column 17, :arglists (quote ([key-fn & colls])), :doc "Outer join of zero or more collections of maps ('rows' or rather: merge'able values),\n  by a key-function.\n  When two or more maps with the same key value (ie. value of applying the\n  key-function to the map), they are merged in order from left to right.\n\n  Be aware that maps where the key-function returns nil are included.\n  Duplicates are not removed.\n\n  Examples:\n\n  (outer-join :a [{:a 1 :b 10 :c 100}{:a 2 :b 20 :c 200}]\n                 [{:a 2 :b 20 :d 200}{:a 3 :b 30 :d 300}])\n  ==> ({:a 1, :b 10, :c 100} {:a 2, :b 20, :c 200, :d 200} {:a 3, :b 30, :d 300})\n\n  (outer-join :a [{:a 1 :b 10 :c 100}{:a 2 :b 20 :c 200}]\n                 [{:a 2 :b 20 :d 200}{:a 2 :b 25 :d 200}{:a 3 :b 30 :d 300}])\n  ==> ({:a 1, :b 10, :c 100} {:a 2, :b 25, :c 200, :d 200} {:a 3, :b 30, :d 300})\n\n  (outer-join :x [{:a 1 :b 10 :c 100}{:a 2 :b 20 :c 200}]\n                 [{:a 2 :b 20 :d 200}{:a 2 :b 25 :d 200}{:a 3 :b 30 :d 300}])\n  ==> ({:a 3, :b 30, :c 200, :d 300})\n\n  (outer-join :a [{:a 1 :b 10 :c 100}{:a 2 :b 20 :c 200}{:a 2 :b 5 :c 500}]\n                 [{:a 2 :b 20 :d 200}{:a 2 :b 25 :d 200}{:a 3 :b 30 :d 300}])\n  ==> ({:a 1, :b 10, :c 100} {:a 2, :b 25, :c 500, :d 200} {:a 3, :b 30, :d 300})\n\n  (outer-join :b [{:a 1 :b 10 :c 100}{:a 2 :b 20 :c 200}{:a 2 :b 5 :c 500}]\n                 [{:a 2 :b 20 :d 200}{:a 2 :b 25 :d 200}{:a 3 :b 30 :d 300}])\n  ==> ({:a 1, :b 10, :c 100} {:a 2, :b 20, :c 200, :d 200}\n       {:a 2, :b 5, :c 500} {:a 2, :b 25, :d 200} {:a 3, :b 30, :d 300})\n\n  (outer-join (juxt :a :b)\n              [{:a 1 :b 10 :c 100}{:a 2 :b 20 :c 200}{:a 2 :b 5 :c 500}]\n              [{:a 2 :b 20 :d 200}{:a 2 :b 25 :d 200}{:a 3 :b 30 :d 300}])\n  ==> ({:a 1, :b 10, :c 100} {:a 2, :b 20, :c 200, :d 200} {:a 2, :b 5, :c 500}\n       {:a 2, :b 25, :d 200} {:a 3, :b 30, :d 300})\n\n  (outer-join (constantly nil)\n            [{:a 1 :b 10 :c 100}{:a 2 :b 20 :c 200}{:a 2 :b 5 :c 500}]\n            [{:a 2 :b 20 :d 200}{:a 2 :b 25 :d 200}{:a 3 :b 30 :d 300}])\n  ==> ({:a 3, :b 30, :c 500, :d 300})\n\n  (outer-join (comp even? :a)\n              [{:a 1 :b 10 :c 100}{:a 2 :b 20 :c 200}{:a 2 :b 5 :c 500}]\n              [{:a 2 :b 20 :d 200}{:a 2 :b 25 :d 200}{:a 3 :b 30 :d 300}]\n  ==> ({:a 3, :b 30, :c 100, :d 300} {:a 2, :b 25, :c 500, :d 200})", :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(key-fn colls)], :arglists ([key-fn & colls]), :arglists-meta (nil)}}, :name bedrock.util/outer-join, :variadic true, :file "src/bedrock/util.cljc", :end-column 17, :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(key-fn colls)], :arglists ([key-fn & colls]), :arglists-meta (nil)}, :method-params [(key-fn colls)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 195, :end-line 195, :max-fixed-arity 1, :fn-var true, :arglists ([key-fn & colls]), :doc "Outer join of zero or more collections of maps ('rows' or rather: merge'able values),\n  by a key-function.\n  When two or more maps with the same key value (ie. value of applying the\n  key-function to the map), they are merged in order from left to right.\n\n  Be aware that maps where the key-function returns nil are included.\n  Duplicates are not removed.\n\n  Examples:\n\n  (outer-join :a [{:a 1 :b 10 :c 100}{:a 2 :b 20 :c 200}]\n                 [{:a 2 :b 20 :d 200}{:a 3 :b 30 :d 300}])\n  ==> ({:a 1, :b 10, :c 100} {:a 2, :b 20, :c 200, :d 200} {:a 3, :b 30, :d 300})\n\n  (outer-join :a [{:a 1 :b 10 :c 100}{:a 2 :b 20 :c 200}]\n                 [{:a 2 :b 20 :d 200}{:a 2 :b 25 :d 200}{:a 3 :b 30 :d 300}])\n  ==> ({:a 1, :b 10, :c 100} {:a 2, :b 25, :c 200, :d 200} {:a 3, :b 30, :d 300})\n\n  (outer-join :x [{:a 1 :b 10 :c 100}{:a 2 :b 20 :c 200}]\n                 [{:a 2 :b 20 :d 200}{:a 2 :b 25 :d 200}{:a 3 :b 30 :d 300}])\n  ==> ({:a 3, :b 30, :c 200, :d 300})\n\n  (outer-join :a [{:a 1 :b 10 :c 100}{:a 2 :b 20 :c 200}{:a 2 :b 5 :c 500}]\n                 [{:a 2 :b 20 :d 200}{:a 2 :b 25 :d 200}{:a 3 :b 30 :d 300}])\n  ==> ({:a 1, :b 10, :c 100} {:a 2, :b 25, :c 500, :d 200} {:a 3, :b 30, :d 300})\n\n  (outer-join :b [{:a 1 :b 10 :c 100}{:a 2 :b 20 :c 200}{:a 2 :b 5 :c 500}]\n                 [{:a 2 :b 20 :d 200}{:a 2 :b 25 :d 200}{:a 3 :b 30 :d 300}])\n  ==> ({:a 1, :b 10, :c 100} {:a 2, :b 20, :c 200, :d 200}\n       {:a 2, :b 5, :c 500} {:a 2, :b 25, :d 200} {:a 3, :b 30, :d 300})\n\n  (outer-join (juxt :a :b)\n              [{:a 1 :b 10 :c 100}{:a 2 :b 20 :c 200}{:a 2 :b 5 :c 500}]\n              [{:a 2 :b 20 :d 200}{:a 2 :b 25 :d 200}{:a 3 :b 30 :d 300}])\n  ==> ({:a 1, :b 10, :c 100} {:a 2, :b 20, :c 200, :d 200} {:a 2, :b 5, :c 500}\n       {:a 2, :b 25, :d 200} {:a 3, :b 30, :d 300})\n\n  (outer-join (constantly nil)\n            [{:a 1 :b 10 :c 100}{:a 2 :b 20 :c 200}{:a 2 :b 5 :c 500}]\n            [{:a 2 :b 20 :d 200}{:a 2 :b 25 :d 200}{:a 3 :b 30 :d 300}])\n  ==> ({:a 3, :b 30, :c 500, :d 300})\n\n  (outer-join (comp even? :a)\n              [{:a 1 :b 10 :c 100}{:a 2 :b 20 :c 200}{:a 2 :b 5 :c 500}]\n              [{:a 2 :b 20 :d 200}{:a 2 :b 25 :d 200}{:a 3 :b 30 :d 300}]\n  ==> ({:a 3, :b 30, :c 100, :d 300} {:a 2, :b 25, :c 500, :d 200})"}, walk-collect {:protocol-inline nil, :meta {:file "/Users/jonasgreen/workspace/stateless/src/bedrock/util.cljc", :line 373, :column 7, :end-line 373, :end-column 19, :arglists (quote ([pred form])), :doc "Walks a form, collecting all elements where predicate holds"}, :name bedrock.util/walk-collect, :variadic false, :file "src/bedrock/util.cljc", :end-column 19, :method-params ([pred form]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 373, :end-line 373, :max-fixed-arity 2, :fn-var true, :arglists (quote ([pred form])), :doc "Walks a form, collecting all elements where predicate holds"}, kw-lowercase {:protocol-inline nil, :meta {:file "/Users/jonasgreen/workspace/stateless/src/bedrock/util.cljc", :line 97, :column 7, :end-line 97, :end-column 19, :arglists (quote ([kw])), :doc "Turn a keyword into lower-case"}, :name bedrock.util/kw-lowercase, :variadic false, :file "src/bedrock/util.cljc", :end-column 19, :method-params ([kw]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 97, :end-line 97, :max-fixed-arity 1, :fn-var true, :arglists (quote ([kw])), :doc "Turn a keyword into lower-case"}, cartesian-product {:protocol-inline nil, :meta {:file "/Users/jonasgreen/workspace/stateless/src/bedrock/util.cljc", :line 313, :column 7, :end-line 313, :end-column 24, :arglists (quote ([] [x] [x & xs])), :doc "Cartesian product of ore or more sequences. Threats scalars as lists of one element", :top-fn {:variadic true, :max-fixed-arity 1, :method-params ([] [x]), :arglists ([] [x] [x & xs]), :arglists-meta (nil nil nil)}}, :name bedrock.util/cartesian-product, :variadic true, :file "src/bedrock/util.cljc", :end-column 24, :top-fn {:variadic true, :max-fixed-arity 1, :method-params ([] [x]), :arglists ([] [x] [x & xs]), :arglists-meta (nil nil nil)}, :method-params ([] [x]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 313, :end-line 313, :max-fixed-arity 1, :fn-var true, :arglists ([] [x] [x & xs]), :doc "Cartesian product of ore or more sequences. Threats scalars as lists of one element"}, flatten-seq {:protocol-inline nil, :meta {:file "/Users/jonasgreen/workspace/stateless/src/bedrock/util.cljc", :line 408, :column 7, :end-line 408, :end-column 18, :arglists (quote ([get-children xs])), :doc "Flatten a sequence.\n\n  Example:\n\n  (flatten-seq :sub\n    [{:id 12\n      :sub [{:id 5 :sub [{:id 67} {:id 99}]}\n            {:id 50}]}])\n  ==> ({:id 12, :sub [{:id 5, :sub [{:id 67} {:id 99}]}\n                    {:id 50}]}\n       {:id 5, :sub [{:id 67} {:id 99}]}\n       {:id 67}\n       {:id 99}\n       {:id 50})"}, :name bedrock.util/flatten-seq, :variadic false, :file "src/bedrock/util.cljc", :end-column 18, :method-params ([get-children xs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 408, :end-line 408, :max-fixed-arity 2, :fn-var true, :arglists (quote ([get-children xs])), :doc "Flatten a sequence.\n\n  Example:\n\n  (flatten-seq :sub\n    [{:id 12\n      :sub [{:id 5 :sub [{:id 67} {:id 99}]}\n            {:id 50}]}])\n  ==> ({:id 12, :sub [{:id 5, :sub [{:id 67} {:id 99}]}\n                    {:id 50}]}\n       {:id 5, :sub [{:id 67} {:id 99}]}\n       {:id 67}\n       {:id 99}\n       {:id 50})"}, partial>> {:protocol-inline nil, :meta {:file "/Users/jonasgreen/workspace/stateless/src/bedrock/util.cljc", :line 17, :column 7, :end-line 17, :end-column 16, :arglists (quote ([f & args])), :doc "As partial, but slices the bound args in AFTER the unbound ones", :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(f args)], :arglists ([f & args]), :arglists-meta (nil)}}, :name bedrock.util/partial>>, :variadic true, :file "src/bedrock/util.cljc", :end-column 16, :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(f args)], :arglists ([f & args]), :arglists-meta (nil)}, :method-params [(f args)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 17, :end-line 17, :max-fixed-arity 1, :fn-var true, :arglists ([f & args]), :doc "As partial, but slices the bound args in AFTER the unbound ones"}, stupid-sleep {:protocol-inline nil, :meta {:file "/Users/jonasgreen/workspace/stateless/src/bedrock/util.cljc", :line 64, :column 7, :end-line 64, :end-column 19, :arglists (quote ([ms])), :doc "Stupid sleep routine that consumes CPU-cycles"}, :name bedrock.util/stupid-sleep, :variadic false, :file "src/bedrock/util.cljc", :end-column 19, :method-params ([ms]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 64, :end-line 64, :max-fixed-arity 1, :fn-var true, :arglists (quote ([ms])), :doc "Stupid sleep routine that consumes CPU-cycles"}, deep-merge {:protocol-inline nil, :meta {:file "/Users/jonasgreen/workspace/stateless/src/bedrock/util.cljc", :line 37, :column 7, :end-line 37, :end-column 17, :arglists (quote ([& args])), :doc "Deep-merges zero or more maps. (Subject to change)", :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(args)], :arglists ([& args]), :arglists-meta (nil)}}, :name bedrock.util/deep-merge, :variadic true, :file "src/bedrock/util.cljc", :end-column 17, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(args)], :arglists ([& args]), :arglists-meta (nil)}, :method-params [(args)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 37, :end-line 37, :max-fixed-arity 0, :fn-var true, :arglists ([& args]), :doc "Deep-merges zero or more maps. (Subject to change)"}, ?call {:protocol-inline nil, :meta {:file "/Users/jonasgreen/workspace/stateless/src/bedrock/util.cljc", :line 284, :column 7, :end-line 284, :end-column 12, :arglists (quote ([f & args])), :doc "Applies f to args if f is a function, otherwise returns f", :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(f args)], :arglists ([f & args]), :arglists-meta (nil)}}, :name bedrock.util/?call, :variadic true, :file "src/bedrock/util.cljc", :end-column 12, :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(f args)], :arglists ([f & args]), :arglists-meta (nil)}, :method-params [(f args)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 284, :end-line 284, :max-fixed-arity 1, :fn-var true, :arglists ([f & args]), :doc "Applies f to args if f is a function, otherwise returns f"}, ?deref {:protocol-inline nil, :meta {:file "/Users/jonasgreen/workspace/stateless/src/bedrock/util.cljc", :line 294, :column 7, :end-line 294, :end-column 13, :arglists (quote ([x])), :doc "Derefs argument if possible, otherwise just returns it unchanged"}, :name bedrock.util/?deref, :variadic false, :file "src/bedrock/util.cljc", :end-column 13, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 294, :end-line 294, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Derefs argument if possible, otherwise just returns it unchanged"}, pp-str {:protocol-inline nil, :meta {:file "/Users/jonasgreen/workspace/stateless/src/bedrock/util.cljc", :line 70, :column 7, :end-line 70, :end-column 13, :arglists (quote ([x])), :doc "pprint to a string"}, :name bedrock.util/pp-str, :variadic false, :file "src/bedrock/util.cljc", :end-column 13, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 70, :end-line 70, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "pprint to a string"}, map-keys {:protocol-inline nil, :meta {:file "/Users/jonasgreen/workspace/stateless/src/bedrock/util.cljc", :line 466, :column 7, :end-line 466, :end-column 15, :arglists (quote ([f coll])), :doc "Maps a function over the keys of an associative collection."}, :name bedrock.util/map-keys, :variadic false, :file "src/bedrock/util.cljc", :end-column 15, :method-params ([f coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 466, :end-line 466, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f coll])), :doc "Maps a function over the keys of an associative collection."}, assoc-where {:protocol-inline nil, :meta {:file "/Users/jonasgreen/workspace/stateless/src/bedrock/util.cljc", :line 50, :column 7, :end-line 50, :end-column 18, :arglists (quote ([_] [_ m] [pred m & next])), :doc "As assoc, but overwrites only values where predicate holds", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([_] [_ m]), :arglists ([_] [_ m] [pred m & next]), :arglists-meta (nil nil nil)}}, :name bedrock.util/assoc-where, :variadic true, :file "src/bedrock/util.cljc", :end-column 18, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([_] [_ m]), :arglists ([_] [_ m] [pred m & next]), :arglists-meta (nil nil nil)}, :method-params ([_] [_ m]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 50, :end-line 50, :max-fixed-arity 2, :fn-var true, :arglists ([_] [_ m] [pred m & next]), :doc "As assoc, but overwrites only values where predicate holds"}, plurality? {:protocol-inline nil, :meta {:file "/Users/jonasgreen/workspace/stateless/src/bedrock/util.cljc", :line 327, :column 7, :end-line 327, :end-column 17, :arglists (quote ([x])), :doc "Is argument a collection with a plurality of elements?"}, :name bedrock.util/plurality?, :variadic false, :file "src/bedrock/util.cljc", :end-column 17, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 327, :end-line 327, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Is argument a collection with a plurality of elements?"}, call-when {:protocol-inline nil, :meta {:file "/Users/jonasgreen/workspace/stateless/src/bedrock/util.cljc", :line 300, :column 7, :end-line 300, :end-column 16, :arglists (quote ([condition f arg0 & rest])), :doc "If condition holds, transform args by applying f to args, otherwise return first arg", :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(condition f arg0 rest)], :arglists ([condition f arg0 & rest]), :arglists-meta (nil)}}, :name bedrock.util/call-when, :variadic true, :file "src/bedrock/util.cljc", :end-column 16, :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(condition f arg0 rest)], :arglists ([condition f arg0 & rest]), :arglists-meta (nil)}, :method-params [(condition f arg0 rest)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 300, :end-line 300, :max-fixed-arity 3, :fn-var true, :arglists ([condition f arg0 & rest]), :doc "If condition holds, transform args by applying f to args, otherwise return first arg"}, soft-join {:protocol-inline nil, :meta {:file "/Users/jonasgreen/workspace/stateless/src/bedrock/util.cljc", :line 7, :column 7, :end-line 7, :end-column 16, :arglists (quote ([delim xs])), :doc "Join a list of elements into a presentation-friendly string"}, :name bedrock.util/soft-join, :variadic false, :file "src/bedrock/util.cljc", :end-column 16, :method-params ([delim xs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 7, :end-line 7, :max-fixed-arity 2, :fn-var true, :arglists (quote ([delim xs])), :doc "Join a list of elements into a presentation-friendly string"}, ?side-effector {:protocol-inline nil, :meta {:file "/Users/jonasgreen/workspace/stateless/src/bedrock/util.cljc", :line 332, :column 7, :end-line 332, :end-column 21, :arglists (quote ([& side-effects])), :doc "Makes an identity function with optional side-effects and optional extra parameters", :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(side-effects)], :arglists ([& side-effects]), :arglists-meta (nil)}}, :name bedrock.util/?side-effector, :variadic true, :file "src/bedrock/util.cljc", :end-column 21, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(side-effects)], :arglists ([& side-effects]), :arglists-meta (nil)}, :method-params [(side-effects)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 332, :end-line 332, :max-fixed-arity 0, :fn-var true, :arglists ([& side-effects]), :doc "Makes an identity function with optional side-effects and optional extra parameters"}, ?set {:protocol-inline nil, :meta {:file "/Users/jonasgreen/workspace/stateless/src/bedrock/util.cljc", :line 319, :column 7, :end-line 319, :end-column 11, :arglists (quote ([x])), :doc "Turn argument into a set, if it isn't one already.\n  nil is turned into an empty set."}, :name bedrock.util/?set, :variadic false, :file "src/bedrock/util.cljc", :end-column 11, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 319, :end-line 319, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Turn argument into a set, if it isn't one already.\n  nil is turned into an empty set."}, ?transform {:protocol-inline nil, :meta {:file "/Users/jonasgreen/workspace/stateless/src/bedrock/util.cljc", :line 289, :column 7, :end-line 289, :end-column 17, :arglists (quote ([f & [arg0 :as args]])), :doc "Applies f to args if f is a function, otherwise returns first arg", :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(f [arg0 :as args])], :arglists ([f & [arg0 :as args]]), :arglists-meta (nil)}}, :name bedrock.util/?transform, :variadic true, :file "src/bedrock/util.cljc", :end-column 17, :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(f [arg0 :as args])], :arglists ([f & [arg0 :as args]]), :arglists-meta (nil)}, :method-params [(f [arg0 :as args])], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 289, :end-line 289, :max-fixed-arity 1, :fn-var true, :arglists ([f & [arg0 :as args]]), :doc "Applies f to args if f is a function, otherwise returns first arg"}, keyaware-merge-with {:protocol-inline nil, :meta {:file "/Users/jonasgreen/workspace/stateless/src/bedrock/util.cljc", :line 146, :column 7, :end-line 146, :end-column 26, :arglists (quote ([f & maps])), :doc "Returns a map that consists of the rest of the maps conj-ed onto\n  the first.  If a key occurs in more than one map, the mapping(s)\n  from the latter (left-to-right) will be combined with the mapping in\n  the result by calling (f key val-in-result val-in-latter).", :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(f maps)], :arglists ([f & maps]), :arglists-meta (nil)}}, :name bedrock.util/keyaware-merge-with, :variadic true, :file "src/bedrock/util.cljc", :end-column 26, :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(f maps)], :arglists ([f & maps]), :arglists-meta (nil)}, :method-params [(f maps)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 146, :end-line 146, :max-fixed-arity 1, :fn-var true, :arglists ([f & maps]), :doc "Returns a map that consists of the rest of the maps conj-ed onto\n  the first.  If a key occurs in more than one map, the mapping(s)\n  from the latter (left-to-right) will be combined with the mapping in\n  the result by calling (f key val-in-result val-in-latter)."}, do-map {:protocol-inline nil, :meta {:file "/Users/jonasgreen/workspace/stateless/src/bedrock/util.cljc", :line 341, :column 7, :end-line 341, :end-column 13, :arglists (quote ([f & args])), :doc "As map, but for side-effects instead of result. Returns the last of the collections to map over", :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(f args)], :arglists ([f & args]), :arglists-meta (nil)}}, :name bedrock.util/do-map, :variadic true, :file "src/bedrock/util.cljc", :end-column 13, :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(f args)], :arglists ([f & args]), :arglists-meta (nil)}, :method-params [(f args)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 341, :end-line 341, :max-fixed-arity 1, :fn-var true, :arglists ([f & args]), :doc "As map, but for side-effects instead of result. Returns the last of the collections to map over"}, replace-template {:protocol-inline nil, :meta {:file "/Users/jonasgreen/workspace/stateless/src/bedrock/util.cljc", :line 119, :column 7, :end-line 119, :end-column 23, :arglists (quote ([text seq]))}, :name bedrock.util/replace-template, :variadic false, :file "src/bedrock/util.cljc", :end-column 23, :method-params ([text seq]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 119, :end-line 119, :max-fixed-arity 2, :fn-var true, :arglists (quote ([text seq]))}, hiccup-table {:protocol-inline nil, :meta {:file "/Users/jonasgreen/workspace/stateless/src/bedrock/util.cljc", :line 356, :column 7, :end-line 356, :end-column 19, :arglists (quote ([{:keys [rows f-cell table-attrib tr-attrib td-attrib]}])), :doc "Creates a hiccup table"}, :name bedrock.util/hiccup-table, :variadic false, :file "src/bedrock/util.cljc", :end-column 19, :method-params ([p__34701]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 356, :end-line 356, :max-fixed-arity 1, :fn-var true, :arglists (quote ([{:keys [rows f-cell table-attrib tr-attrib td-attrib]}])), :doc "Creates a hiccup table"}, partial-1 {:protocol-inline nil, :meta {:file "/Users/jonasgreen/workspace/stateless/src/bedrock/util.cljc", :line 22, :column 7, :end-line 22, :end-column 16, :arglists (quote ([f & args])), :doc "As partial, but slices the bound args in after the first unbound one", :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(f args)], :arglists ([f & args]), :arglists-meta (nil)}}, :name bedrock.util/partial-1, :variadic true, :file "src/bedrock/util.cljc", :end-column 16, :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(f args)], :arglists ([f & args]), :arglists-meta (nil)}, :method-params [(f args)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 22, :end-line 22, :max-fixed-arity 1, :fn-var true, :arglists ([f & args]), :doc "As partial, but slices the bound args in after the first unbound one"}, provide! {:protocol-inline nil, :meta {:file "/Users/jonasgreen/workspace/stateless/src/bedrock/util.cljc", :line 455, :column 7, :end-line 455, :end-column 15, :arglists (quote ([state path id f]))}, :name bedrock.util/provide!, :variadic false, :file "src/bedrock/util.cljc", :end-column 15, :method-params ([state path id f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 455, :end-line 455, :max-fixed-arity 4, :fn-var true, :arglists (quote ([state path id f]))}, comp-and {:protocol-inline nil, :meta {:file "/Users/jonasgreen/workspace/stateless/src/bedrock/util.cljc", :line 112, :column 7, :end-line 112, :end-column 15, :arglists (quote ([pred1 pred2]))}, :name bedrock.util/comp-and, :variadic false, :file "src/bedrock/util.cljc", :end-column 15, :method-params ([pred1 pred2]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 112, :end-line 112, :max-fixed-arity 2, :fn-var true, :arglists (quote ([pred1 pred2]))}, cross-join {:protocol-inline nil, :meta {:file "/Users/jonasgreen/workspace/stateless/src/bedrock/util.cljc", :line 245, :column 7, :end-line 245, :end-column 17, :arglists (quote ([rel1 rel2 & [where merge-fn]])), :doc "Cross join of over two collections, with optional\n  predicate (row1,row2 -> bool) and merge-function.\n  Default merge-function is the standard merge, making the\n  function suitable for non-relation operations too.\n  Duplicates are not removed.\n\n  Example:\n\n  (cross-join [{:a 1} {:a 2}] [{:b 1} {:b 2} {:b 3}])\n  ==> ({:a 1, :b 1} {:a 1, :b 2} {:a 1, :b 3}\n       {:a 2, :b 1} {:a 2, :b 2} {:a 2, :b 3})\n\n  (cross-join [] [{:b 1} {:b 2} {:b 3}])\n  ==> nil\n\n  (cross-join [{:a 1 :x 'one} {:a 2 :x 'two}]\n              [{:b 1} {:b 2 :x 'this :y 'is-it} {:b 3 :x 'that}])\n  ==> ({:a 1, :x one, :b 1} {:a 1, :x this, :b 2, :y is-it} {:a 1, :x that, :b 3}\n       {:a 2, :x two, :b 1} {:a 2, :x this, :b 2, :y is-it} {:a 2, :x that, :b 3}\n\n  (cross-join [{:a 1 :x 'one} {:a 2 :x 'two}]\n              [{:b 1} {:b 2 :x 'this :y 'is-it} {:b 3 :x 'that}]\n              #(= (:a %) (:b %2)))\n  ==> ({:a 1, :x one, :b 1} {:a 2, :x this, :b 2, :y is-it})\n\n  (cross-join [{:a 1 :x 'one} {:a 2 :x 'two}]\n              [{:b 1} {:b 2 :x 'this :y 'is-it} {:b 3 :x 'that}]\n              #(=(:a %) (:b %2))\n              #(assoc % :z %2))\n  ==> ({:a 1, :x one, :z {:b 1}} {:a 2, :x two, :z {:b 2, :x this, :y is-it}})\n\n  (cross-join [3 5 7 8] [100 200 300 401] #(even? %2) +)\n  ==> (103 203 303 105 205 305 107 207 307 108 208 308)", :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(rel1 rel2 [where merge-fn])], :arglists ([rel1 rel2 & [where merge-fn]]), :arglists-meta (nil)}}, :name bedrock.util/cross-join, :variadic true, :file "src/bedrock/util.cljc", :end-column 17, :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(rel1 rel2 [where merge-fn])], :arglists ([rel1 rel2 & [where merge-fn]]), :arglists-meta (nil)}, :method-params [(rel1 rel2 [where merge-fn])], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 245, :end-line 245, :max-fixed-arity 2, :fn-var true, :arglists ([rel1 rel2 & [where merge-fn]]), :doc "Cross join of over two collections, with optional\n  predicate (row1,row2 -> bool) and merge-function.\n  Default merge-function is the standard merge, making the\n  function suitable for non-relation operations too.\n  Duplicates are not removed.\n\n  Example:\n\n  (cross-join [{:a 1} {:a 2}] [{:b 1} {:b 2} {:b 3}])\n  ==> ({:a 1, :b 1} {:a 1, :b 2} {:a 1, :b 3}\n       {:a 2, :b 1} {:a 2, :b 2} {:a 2, :b 3})\n\n  (cross-join [] [{:b 1} {:b 2} {:b 3}])\n  ==> nil\n\n  (cross-join [{:a 1 :x 'one} {:a 2 :x 'two}]\n              [{:b 1} {:b 2 :x 'this :y 'is-it} {:b 3 :x 'that}])\n  ==> ({:a 1, :x one, :b 1} {:a 1, :x this, :b 2, :y is-it} {:a 1, :x that, :b 3}\n       {:a 2, :x two, :b 1} {:a 2, :x this, :b 2, :y is-it} {:a 2, :x that, :b 3}\n\n  (cross-join [{:a 1 :x 'one} {:a 2 :x 'two}]\n              [{:b 1} {:b 2 :x 'this :y 'is-it} {:b 3 :x 'that}]\n              #(= (:a %) (:b %2)))\n  ==> ({:a 1, :x one, :b 1} {:a 2, :x this, :b 2, :y is-it})\n\n  (cross-join [{:a 1 :x 'one} {:a 2 :x 'two}]\n              [{:b 1} {:b 2 :x 'this :y 'is-it} {:b 3 :x 'that}]\n              #(=(:a %) (:b %2))\n              #(assoc % :z %2))\n  ==> ({:a 1, :x one, :z {:b 1}} {:a 2, :x two, :z {:b 2, :x this, :y is-it}})\n\n  (cross-join [3 5 7 8] [100 200 300 401] #(even? %2) +)\n  ==> (103 203 303 105 205 305 107 207 307 108 208 308)"}, add-reagent-keys {:protocol-inline nil, :meta {:file "/Users/jonasgreen/workspace/stateless/src/bedrock/util.cljc", :line 347, :column 7, :end-line 347, :end-column 23, :arglists (quote ([xs])), :doc "Adds reagent keys to a sequence. Keys will be added where none exist (as meta-data or [:div {:key xxx}]) , and existing keys will not be reused"}, :name bedrock.util/add-reagent-keys, :variadic false, :file "src/bedrock/util.cljc", :end-column 23, :method-params ([xs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 347, :end-line 347, :max-fixed-arity 1, :fn-var true, :arglists (quote ([xs])), :doc "Adds reagent keys to a sequence. Keys will be added where none exist (as meta-data or [:div {:key xxx}]) , and existing keys will not be reused"}, map-vals {:protocol-inline nil, :meta {:file "/Users/jonasgreen/workspace/stateless/src/bedrock/util.cljc", :line 470, :column 7, :end-line 470, :end-column 15, :arglists (quote ([f coll])), :doc "Maps a function over the values of an associative collection."}, :name bedrock.util/map-vals, :variadic false, :file "src/bedrock/util.cljc", :end-column 15, :method-params ([f coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 470, :end-line 470, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f coll])), :doc "Maps a function over the values of an associative collection."}, merge-proper {:protocol-inline nil, :meta {:file "/Users/jonasgreen/workspace/stateless/src/bedrock/util.cljc", :line 45, :column 7, :end-line 45, :end-column 19, :arglists (quote ([m & maps])), :doc "As merge, but does not overwrite with values that are nil", :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(m maps)], :arglists ([m & maps]), :arglists-meta (nil)}}, :name bedrock.util/merge-proper, :variadic true, :file "src/bedrock/util.cljc", :end-column 19, :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(m maps)], :arglists ([m & maps]), :arglists-meta (nil)}, :method-params [(m maps)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 45, :end-line 45, :max-fixed-arity 1, :fn-var true, :arglists ([m & maps]), :doc "As merge, but does not overwrite with values that are nil"}, comp-or {:protocol-inline nil, :meta {:file "/Users/jonasgreen/workspace/stateless/src/bedrock/util.cljc", :line 107, :column 7, :end-line 107, :end-column 14, :arglists (quote ([pred1 pred2]))}, :name bedrock.util/comp-or, :variadic false, :file "src/bedrock/util.cljc", :end-column 14, :method-params ([pred1 pred2]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 107, :end-line 107, :max-fixed-arity 2, :fn-var true, :arglists (quote ([pred1 pred2]))}, assoc-some {:protocol-inline nil, :meta {:file "/Users/jonasgreen/workspace/stateless/src/bedrock/util.cljc", :line 126, :column 7, :end-line 126, :end-column 17, :arglists (quote ([m & kvs])), :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(m kvs)], :arglists ([m & kvs]), :arglists-meta (nil)}}, :name bedrock.util/assoc-some, :variadic true, :file "src/bedrock/util.cljc", :end-column 17, :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(m kvs)], :arglists ([m & kvs]), :arglists-meta (nil)}, :method-params [(m kvs)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 126, :end-line 126, :max-fixed-arity 1, :fn-var true, :arglists ([m & kvs])}, graph-collect-tree {:protocol-inline nil, :meta {:file "/Users/jonasgreen/workspace/stateless/src/bedrock/util.cljc", :line 132, :column 8, :end-line 132, :end-column 26, :private true, :arglists (quote ([map-graph child-lister start-key & flags])), :doc "Collects the keys of a tree of nodes starting from start-key and enumerated by child-lister.\n  Optional flag :pre-order / :post-order\n  :pre-order is default", :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(map-graph child-lister start-key flags)], :arglists ([map-graph child-lister start-key & flags]), :arglists-meta (nil)}}, :private true, :name bedrock.util/graph-collect-tree, :variadic true, :file "src/bedrock/util.cljc", :end-column 26, :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(map-graph child-lister start-key flags)], :arglists ([map-graph child-lister start-key & flags]), :arglists-meta (nil)}, :method-params [(map-graph child-lister start-key flags)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 132, :end-line 132, :max-fixed-arity 3, :fn-var true, :arglists ([map-graph child-lister start-key & flags]), :doc "Collects the keys of a tree of nodes starting from start-key and enumerated by child-lister.\n  Optional flag :pre-order / :post-order\n  :pre-order is default"}, walker {:protocol-inline nil, :meta {:file "/Users/jonasgreen/workspace/stateless/src/bedrock/util.cljc", :line 381, :column 7, :end-line 381, :end-column 13, :arglists (quote ([& {:keys [get-children update-children pre-children post-children pre-node post-node pre-root post-root root-wrapper]}])), :doc "Makes a walker-function.", :top-fn {:variadic true, :max-fixed-arity 0, :method-params [({:keys [get-children update-children pre-children post-children pre-node post-node pre-root post-root root-wrapper]})], :arglists ([& {:keys [get-children update-children pre-children post-children pre-node post-node pre-root post-root root-wrapper]}]), :arglists-meta (nil)}}, :name bedrock.util/walker, :variadic true, :file "src/bedrock/util.cljc", :end-column 13, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [({:keys [get-children update-children pre-children post-children pre-node post-node pre-root post-root root-wrapper]})], :arglists ([& {:keys [get-children update-children pre-children post-children pre-node post-node pre-root post-root root-wrapper]}]), :arglists-meta (nil)}, :method-params [({:keys [get-children update-children pre-children post-children pre-node post-node pre-root post-root root-wrapper]})], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 381, :end-line 381, :max-fixed-arity 0, :fn-var true, :arglists ([& {:keys [get-children update-children pre-children post-children pre-node post-node pre-root post-root root-wrapper]}]), :doc "Makes a walker-function."}}, :cljs.spec/registry-ref [], :require-macros {cljs.pprint cljs.pprint}, :cljs.analyzer/constants {:seen #{:children :table-attrib :v :short :post-children :pre-root :tbody :full :table :key :else :post-root :post-order :td :tr :post-node :==> :get-children :td-attrib :rows :root-wrapper :id :tr-attrib :update-children :pre-children :pre-node :f-cell}, :order [:else :short :full :post-order :key :rows :f-cell :table-attrib :tr-attrib :td-attrib :table :tbody :tr :td :get-children :update-children :pre-children :post-children :pre-node :post-node :pre-root :post-root :root-wrapper :children :==> :id :v]}, :doc nil}